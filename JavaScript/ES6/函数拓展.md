## 函数拓展

### 指定参数默认值

ES6支持给函数的参数指定默认值。没有参数或者显示传入undefined会触发该参数等于默认值，null则没有这种效果。

```javascript
function add(x = 0, y = 0) {
  return a + b
}
```

优点：

1. 代码简洁，省去判断和赋值操作。
2. 方便阅读，哪些参数可省略一目了然。

**注意**

1. 不允许重名参数(与参数作用域有关)。

   ```javascript
   function add(a, a, b) {
     return a + a + b
   }
   add(1, 2, 3) //7
   function add1(a = 0, a = 0, b = 0) {
     return a + a + b
   } //error
   ```

2. 参数的默认值若是变量或表达式，惰性求值。

   ```javascript
   let initData = 1
   function add(a = 0, b = initData) {
     return a + b
   }
   initData++;
   add(2) //4
   ```

#### length属性

返回(第一个指定默认值的参数之前的)未指定默认值的参数个数，用于统计预期传入的参数个数。

```javascript
(function(a = 0, b) {}).length //0
(function(a, b = 0) {}).length //1
(function(a, b) {}).length //2
(function(...args) {}).length //0
```

#### 参数解构赋值

等号左边是匹配模式，等号右边是默认值。

```javascript
function whoIs({userName:name = "none", age} = {}) {
  console.log(`${name}-${age}`)
}
whoIs({age: 12}) //none-12
whoIs() //none-undefined
whoIs({userName: "Tom", age: 12}) //Tom-12
```

#### 参数的作用域

一旦设置了参数的默认值，在函数进行初始化声明的时候，参数会形成一个独立的作用域，相当于在参数作用域中按顺序给参数进行声明并且赋值。

1. 若默认值中的变量与参数作用域中的参数同名
   * 该参数已声明并且赋值，默认值来自该参数
   * 该参数未声明，报错
2. 若默认值中的变量与参数作用域中的参数不同名，沿着作用域链查找变量

```javascript
var a = 10
var x = 14
function add(a, b = x, c = a) {
  return a + b + c;
}
add(12) //38
/*
{
  let a = 12
	let b = x //14
  let c = a //12
}
*/
function add(a = a, b = 12) {
  return a + b
}
add() //ReferenceError: a is not defined
/*
{
	let a = a //ReferenceError: a is not defined
	let b = 12
}
*/
```

在函数内，可以声明与参数重名的变量，因为函数内的变量与参数不在同一个作用域内，所以不是一个变量。

### name属性

返回函数名。

这个属性本身就已经被多个浏览器支持了，ES6对其做了标准化。

```javascript
(function add() {}).name //"add"
```

不过，ES6对这个属性的行为做了一些修改。

1. 如果将匿名函数赋值给一个变量

```javascript
let f = function() {}
//ES5
f.name //""
//ES6
f.name //"f"
```

2. 如果将具名函数赋值给一个变量

```javascript
let f = function f1() {}
//ES5
f.name //"f1"
//ES6
f.name //"f1"
```

3. Function构造函数返回的函数实例，name为anonymous
4. bind返回的函数，name会加上`bound `加空格的前缀：`bound function_name`

### 拓展运算符(...rest参数)

`...变量名`，返回的变量是一个参数数组，用来取代arguments对象，可传入任意数目的参数。

```javascript
function add(...nums) {
  return nums.reduce((prev, current) => {
    return prev + current;
  }, 0)
}
add(1, 2, 3) //6
add(4, 5, 6, 7) //22
```

`arguments`对象并不是数组，而是类似数组的对象，所以它自身不带有数组的方法，如果想要使用数组的方法，必须先使用`Array.propotype.slice.call`将其转为数组。

```javascript
function add() {
  return Array.prototype.slice.call(arguments).reduce((prev, current) => {
    return prev + current;
  }, 0)
}
add(1, 2, 3) //6
add(4, 5, 6, 7) //22
```

而rest参数则不存在这个问题，因为它本身就是一个真正的数组，数组特有的方法它都可以使用。

但是需要注意的是：

1. rest参数后面不能有其他参数。
2. rest参数可以传入多余的任意数目的参数，也就意味着rest参数能够传入参数的数目区间是[0, Infinity)，并且只有在函数执行的时候才能知道参数数目。对于函数的length属性，会直接忽略rest参数。

### 箭头函数

#### 基本用法

使用`=>`定义函数。

```javascript
let add = (a, b) => {return a + b}
//等同于
let add = function(a, b) {
  return a + b
}
```

如果没有参数或需要多个参数，需要使用圆括号代替参数部分，不能省去圆括号。

如果只有一个参数，可以省略圆括号。

如果

### 严格模式

ES5：通过`use strict`设定严格模式。

ES6：只要参数使用了**默认值**、**解构赋值**、**拓展运算符**，不允许在函数内部显示设定严格模式，否则会报错。

函数体内部的严格模式，同时适用于函数体和函数参数，但是只有在函数体执行之后才能知道函数参数是否要以严格模式执行。但是在使用了**默认值**等的ES6函数中，函数参数先于函数体执行。如果函数参数中有不符合严格模式的参数存在，会导致函数体报错。比如：

```javascript
function test(num = 010) {
  'use strict'
  return num
} //error
```

为了规避这种限制，你需要将`use strict`写在方法外。

