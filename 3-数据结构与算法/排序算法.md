# 排序算法

## 什么是稳定排序？
待排序的序列中可能存在两个或以上相等的数值，排序前序列中i<j且Ri==Rj，在排序后这种关系仍然成立。那么所使用的排序算法是稳定的。

## 算法整理
### 冒泡排序
原理：依次比较相邻的元素，通过交换将较小的元素浮动到序列顶端(将最大的元素沉到序列底部)。
```C++
int temp;
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
```
#### 时间复杂度
**最好情况：** 序列初始状态是正序，时间花销为n * (n - 1) / 2，所以时间复杂度为O(n2)。但也有的说法是O(n)，前提是使用标志位来判断是否排好序。

**最坏情况：** 序列初始状态是倒序，每次排序都要通过3个步骤来交换元素，时间花销为3 * n * (n - 1) / 2， 所以时间复杂度为O(n2)。

**平均时间复杂度：** O(n2)

#### 空间复杂度
即交换元素时临时变量所占的内存空间，为O(1)。

#### 稳定性

冒泡排序是发生在相邻元素之间的比较和交换，如果两个元素相等是不会发生交换的，所以相同元素排序前后顺序没有改变，"冒泡排序"是一种稳定排序算法。

### 直接插入排序

将元素插入已经排好序的序列中。

```c++
for (int i = 1; i < n; i++) {
    
    if (arr[i] >= arr[i - 1]) continue;
    
    int j = i - 1, temp = a[i];
    for (; j >= 0 && a[j] > temp; j--) {
        a[j + 1] = a[j];
    }
    a[j + 1] = temp;
}
```
#### 时间复杂度
**最好情况：** 序列初始状态是正序，时间花销为n - 1，所以时间复杂度为O(n)。

**最坏情况：** 序列初始状态是倒序，时间花销为n * (n - 1) / 2， 所以时间复杂度为O(n2)。

**平均时间复杂度：** O(n2)

#### 空间复杂度
即插入过程中临时变量所占的内存空间，为O(1)。

#### 稳定性
直接插入排序指的是将元素插入到已经排好序的序列中，如果存在相等元素，则插入到相等元素区间的尾部，最终序列满足Ri==Rj时i<j，所以直接插入排序是稳定的排序算法。

### 直接选择排序
原理：从R[i]~R[n-1]中选取最小值，与R[i]做交换，经过n-1次交换后，能得到一个从小到大的有序序列。
```C++
for (int i = 0; i < n - 1; i++) {
    int minIndex = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIndex]) minIndex = j;
    }
    if (minIndex != i) {
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```
#### 时间复杂度
直接插入排序的时间复杂度是 **固定的** O(n2)。

#### 空间复杂度
临时变量占用的内存空间为O(1)。

#### 稳定性
直接选择排序的原理是：从R[i]~R[n-1]中选取最小值，与R[i]做交换。这意味着Ri可能与Rj之后的元素进行交换，破坏了Ri和Rj的相对顺序。所以直接选择排序是不稳定的排序算法。

### 快速排序
快速排序是冒泡排序基于二分法改进的版本。

将待排序序列分割成两个独立的部分，其中一部分所有数据都要比另外一部分的所有数据小，再按此类方法对这两部分数据分别进行快速排序，以此类推，直到序列有序为止。

```c++
void quitsort(int arr[], int left, int right) {
    if (left >= right) return;
    
    int i = left + 1, j = right, base = arr[left];
    while (i != j) {
        while (arr[i] <= base && i < j) {
            i++;
        }
        while (arr[j] >= base && i < j) {
            j--;
        }
        if (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    if (i != left) {
        a[left] = a[i];
        a[i] = base;
    }
    quitsort(arr, left, i - 1);
    quitsort(arr, i + 1, right);
    return;
}
```
#### 时间复杂度

**最好情况：** 每次取到的元素正好平分整个数组，时间复杂度为O(nlog2n)。

**最坏情况：** 序列初始状态是倒序，这种情况就等于是做冒泡排序，n * (n - 1) / 2所以时间复杂度与冒泡排序一样为为O(n2)。

**平均时间复杂度：** O(nlog2n)

#### 空间复杂度
与时间复杂度相同为：O(nlog2n)

#### 稳定性
根据快排原理，未排序的序列被分割成两个独立的部分，那么这两个独立的部分就不存在相对顺序的概念了，所以快速排序是不稳定的排序算法。

### 归并排序
分治法的典型应用：先让子序列有序，再使子序列之间有序，最终将两个有序子序列合并成一个有序序列。

```c++

```


### 希尔插入排序

### 堆排序

### 基数排序

